//   _            _           _                        _        _
//  (_)          | |         | |                      | |      (_)
//   _ _ __   ___| |_   _  __| | ___    ___ ___  _ __ | |_ __ _ _ _ __   ___ _ __
//  | | '_ \ / __| | | | |/ _` |/ _ \  / __/ _ \| '_ \| __/ _` | | '_ \ / _ \ '__|
//  | | | | | (__| | |_| | (_| |  __/ | (_| (_) | | | | || (_| | | | | |  __/ |
//  |_|_| |_|\___|_|\__,_|\__,_|\___|  \___\___/|_| |_|\__\__,_|_|_| |_|\___|_|
//
//      Simple, elegant and maintainable container queries in Sass
//                             v1.0.2
//
//           https://github.com/PaulLVG/include-container
//           https://paullvg.github.io/include-container/
//
//      Respectful adaptation of `include-media` by Eduardo Boucas
//      & Kitty Giraudel, adapted to support container queries.
//      Original: https://eduardoboucas.github.io/include-media/
//
//      MIT License — Maintained by @PaulLVG

@use "sass:math";
@use "sass:map";
@use "sass:list";
@use "sass:string";
@use "sass:meta";

// -----------------------------------------------------------------------------
// Public configuration (override before @use)
// -----------------------------------------------------------------------------

/// Named breakpoints used in shorthand conditions like '>=md'
$ic-breakpoints: (
  "xxs": 320px,
  "xs":  480px,
  "sm":  640px,
  "md":  768px,
  "lg":  1024px,
  "xl":  1280px,
  "xxl": 1536px
) !default;

/// Unit deltas for exclusive ranges `>` and `<`
/// e.g. '> 40ch' -> 40ch + 0.1ch, '< 60ch' -> 60ch - 0.1ch
$ic-unit-intervals: (
  "px": 1,
  "em": 0.01,
  "rem": 0.1, // common with :root { font-size: 62.5% }
  "ch": 0.1,
  "":  0
) !default;

/// Wraps output in @supports (container-type: inline-size|size)
$ic-guard-supports: true !default;

// -----------------------------------------------------------------------------
// Private helpers (parsing & utilities)
// -----------------------------------------------------------------------------

/// Returns the operator found in the expression
/// @return String: one of '>=', '>', '<=', '<', '≥', '≤'
@function _ic-operator($expr) {
  @each $op in (">=", ">", "<=", "<", "≥", "≤") {
    @if string.index($expr, $op) {
      @return $op;
    }
  }
  @return null;
}

/// Returns 'width' (inline-size) or provided dimension before the operator
/// e.g. 'height >= 40ch' -> 'height', '>=md' -> 'width'
@function _ic-dimension($expr, $op) {
  $i: string.index($expr, $op);
  @if $i == null { @return "width"; }
  $raw: _ic-trim(string.slice($expr, 1, $i - 1));
  @return if(string.length($raw) > 0, $raw, "width");
}

/// Returns 'min' for >=, > and 'max' for <=, <
@function _ic-prefix($op) {
  @return if(list.index(("<", "<=", "≤"), $op), "max", "min");
}

/// Converts a string like "768px" or "40ch" or a named breakpoint into a number with unit
@function _ic-value($expr, $op) {
  $i: string.index($expr, $op);
  @if $i == null {
    @error "No operator found in `#{$expr}`.";
  }

  $raw: _ic-trim(string.slice($expr, $i + string.length($op)));
  // Named breakpoint?
  $val: null;
  @if map.has-key($ic-breakpoints, $raw) {
    $val: map.get($ic-breakpoints, $raw);
  } @else {
    $val: _ic-to-number($raw);
  }

  $unit: math.unit($val);
  $delta: map.get($ic-unit-intervals, $unit);
  @if $delta == null {
    @error "Unknown unit `#{$unit}` in `#{$expr}`.";
  }

  @if $op == ">" {
    @return $val + $delta;
  } @else if $op == "<" {
    @return $val - $delta;
  } @else {
    @return $val;
  }
}

/// Parses a single condition into a parenthesized container condition string
/// Accepts:
///   - '>=md'            -> '(min-width: 768px)'
///   - '<=lg'            -> '(max-width: 1024px)'
///   - 'height >= 40ch'  -> '(min-height: 40.1ch)'
///   - raw CSS in parens -> '(aspect-ratio > 1/1)' (returned as-is)
@function _ic-parse($expr) {
  // Already a parenthesized raw condition: return as-is
  $trim: _ic-trim($expr);
  @if string.slice($trim, 1, 1) == "(" {
    @return $trim;
  }

  $op: _ic-operator($trim);
  @if $op == null {
    // No operator: assume >= named breakpoint, e.g. 'md' => '(min-width: <val>)'
    @if map.has-key($ic-breakpoints, $trim) {
      @return "(min-width: #{map.get($ic-breakpoints, $trim)})";
    }
    @error "No operator and not a known breakpoint in `#{$expr}`.";
  }

  $dim: _ic-dimension($trim, $op);
  $pre: _ic-prefix($op);
  $val: _ic-value($trim, $op);
  @return "(#{$pre}-#{$dim}: #{$val})";
}

/// Trims leading/trailing spaces
@function _ic-trim($s) {
  @if string.slice($s, 1, 1) == " "  { @return _ic-trim(string.slice($s, 2)); }
  @if string.slice($s, -1, -1) == " " { @return _ic-trim(string.slice($s, 1, -2)); }
  @return $s;
}

/// Slices a list from start index to end (inclusive)
@function _ic-slice($list, $start: 1, $end: list.length($list)) {
  $result: ();
  @if $start < 1 { $start: 1; }
  @if $end > list.length($list) { $end: list.length($list); }
  @if $start > $end { @return $result; }

  @for $i from $start through $end {
    $result: list.append($result, list.nth($list, $i), comma);
  }
  @return $result;
}

/// Casts a string like "40ch" or "768px" to a number with unit
@function _ic-to-number($value) {
  @if meta.type-of($value) == "number" {
    @return $value;
  } @else if meta.type-of($value) != "string" {
    @error "Value for `_ic-to-number` should be a number or a string.";
  }

  $first: string.slice($value, 1, 1);
  $minus: ($first == "-");
  $work: if(($first == "+") or ($first == "-"), string.slice($value, 2), $value);

  $result: 0;
  $digits: 0;
  $digits-map: ("0":0,"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9);

  @for $i from 1 through string.length($work) {
    $ch: string.slice($work, $i, $i);
    @if not(list.index(map.keys($digits-map), $ch) or $ch == ".") {
      @return _ic-to-length(if($minus, -$result, $result), string.slice($work, $i));
    }
    @if $ch == "." {
      $digits: 1;
    } @else if $digits == 0 {
      $result: $result * 10 + map.get($digits-map, $ch);
    } @else {
      $digits: $digits * 10;
      $result: $result + math.div(map.get($digits-map, $ch), $digits);
    }
  }

  @return if($minus, -$result, $result);
}

/// Adds a unit string to a unitless number
@function _ic-to-length($val, $unit) {
  $units: (
    "px": 1px, "cm": 1cm, "mm": 1mm, "%": 1%, "ch": 1ch, "pc": 1pc, "in": 1in,
    "em": 1em, "rem": 1rem, "pt": 1pt, "ex": 1ex, "vw": 1vw, "vh": 1vh,
    "vmin": 1vmin, "vmax": 1vmax
  );
  @if not map.has-key($units, $unit) {
    @error "Invalid unit `#{$unit}`.";
  }
  @return $val * map.get($units, $unit);
}

/// Internal: builds the full @container clause (with optional name)
/// result example: "layout (min-width: 768px)"  OR  "(min-width: 768px)"
@function _ic-clause($first-cond, $name) {
  $cond: _ic-parse($first-cond);
  @return if($name == null, $cond, "#{$name} #{$cond}");
}

/// Internal: extracts trailing options map if present
/// Allowed keys: name, type, supports
@function _ic-pop-options($conds) {
  @if list.length($conds) == 0 { @return (options: (), rest: ()); }
  $last: list.nth($conds, list.length($conds));
  @if meta.type-of($last) == "map" {
    $rest: ();
    @for $i from 1 through list.length($conds) - 1 {
      $rest: list.append($rest, list.nth($conds, $i), comma);
    }
    @return (options: $last, rest: $rest);
  }
  @return (options: (), rest: $conds);
}

// -----------------------------------------------------------------------------
// Public: context mixin to temporarily extend breakpoints (tweakpoints)
// -----------------------------------------------------------------------------

/// Temporarily extends the global breakpoints within the block scope
/// @param {Map} $tweakpoints - extra breakpoints to merge
/// @example scss
///   @include container-context(("tall": 70ch)) {
///     @include container("height >= tall") { /* ... */ }
///   }
@mixin container-context($tweakpoints: ()) {
  $saved: $ic-breakpoints;
  $ic-breakpoints: map.merge($ic-breakpoints, $tweakpoints) !global;
  @content;
  $ic-breakpoints: $saved !global;
}

// -----------------------------------------------------------------------------
// Public: main mixin
// -----------------------------------------------------------------------------

/// Generates @container rules from shorthand conditions.
/// Usage:
///   @include container('>=md') { .. }
///   @include container('height >= 40ch') { .. }
///   @include container('>=sm', '<=lg') { .. } // AND logic by nesting
///   @include container('>=lg', $name: 'layout') { .. }
///   @include container('>=lg', $name: 'layout', $type: 'size') { .. }
///
/// Options (via named parameters or trailing map):
///   - $name: <string>    -> container-name to target
///   - $type: 'inline-size'|'size' (default inline-size for @supports)
///   - $supports: bool    -> wrap in @supports (defaults to $ic-guard-supports)
///
/// Notes:
/// - When multiple conditions are provided, the mixin nests @container blocks,
///   which is equivalent to logical AND.
@mixin container($conditions...) {
  // Extract (optional) trailing options map
  $parsed: _ic-pop-options($conditions);
  $opts: map.get($parsed, options);
  $rest: map.get($parsed, rest);

  $final-name: map.get($opts, name);
  $final-type: if(map.has-key($opts, type), map.get($opts, type), null);
  $supports-flag: if(map.has-key($opts, supports), map.get($opts, supports), $ic-guard-supports);

  @if list.length($rest) == 0 {
    @error "include-container: at least one condition is required.";
  }

  $first: list.nth($rest, 1);
  $clause: _ic-clause($first, $final-name);

  // Decide which container-type to guard for @supports
  $guard-type: if($final-type == "size", "size", "inline-size");

  @if $supports-flag {
    @supports (container-type: #{$guard-type}) {
      // Note: VSCode CSS linter may show an error here, but this is valid Sass syntax
      // The interpolation #{string.unquote($clause)} generates correct @container rules at compile time
      @container #{string.unquote($clause)} {
        @if list.length($rest) > 1 {
          // Recursively handle remaining conditions with supports disabled
          $tail-with-opts: list.append(_ic-slice($rest, 2), (name: $final-name, type: $final-type, supports: false), comma);
          @include container($tail-with-opts...) {
            @content;
          }
        } @else {
          @content;
        }
      }
    }
  } @else {
    // Note: VSCode CSS linter may show an error here, but this is valid Sass syntax
    // The interpolation #{string.unquote($clause)} generates correct @container rules at compile time
    @container #{string.unquote($clause)} {
      @if list.length($rest) > 1 {
        // Recursively handle remaining conditions
        $tail-with-opts: list.append(_ic-slice($rest, 2), (name: $final-name, type: $final-type, supports: false), comma);
        @include container($tail-with-opts...) {
          @content;
        }
      } @else {
        @content;
      }
    }
  }
}

// Backwards-compatible alias (if another mixin named `container` exists in a project)
/// @alias include-container
@mixin include-container($conditions...) {
  @include container($conditions...) {
    @content;
  }
}