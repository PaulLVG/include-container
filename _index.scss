//   _            _           _                        _        _                 
//  (_)          | |         | |                      | |      (_)                
//   _ _ __   ___| |_   _  __| | ___    ___ ___  _ __ | |_ __ _ _ _ __   ___ _ __ 
//  | | '_ \ / __| | | | |/ _` |/ _ \  / __/ _ \| '_ \| __/ _` | | '_ \ / _ \ '__|
//  | | | | | (__| | |_| | (_| |  __/ | (_| (_) | | | | || (_| | | | | |  __/ |   
//  |_|_| |_|\___|_|\__,_|\__,_|\___|  \___\___/|_| |_|\__\__,_|_|_| |_|\___|_|   
//
//      Simple, elegant and maintainable container queries in Sass
//                             v1.0.0
//
//           https://github.com/PaulLVG/include-container
//           https://paullvg.github.io/include-container/
//
//      Respectful adaptation of `include-media` by Eduardo Boucas
//      & Kitty Giraudel, adapted to support container queries.
//      Original repo: https://eduardoboucas.github.io/include-media/
//      Fork maintained by: PaulLVG (https://github.com/PaulLVG)
//
//      This project is licensed under the terms of the MIT license.

@use "sass:math";
@use "sass:map";
@use "sass:list";
@use "sass:string";
@use "sass:meta";

// -----------------------------------------------------------------------------
// Public configuration (override BEFORE @use when vendoring, or via Sass loader)
// -----------------------------------------------------------------------------

/// Named breakpoints for shorthand conditions like `'>=md'`.
/// @type Map
$ic-breakpoints: (
  "xxs": 320px,
  "xs":  480px,
  "sm":  640px,
  "md":  768px,
  "lg":  1024px,
  "xl":  1280px,
  "xxl": 1536px
) !default;

/// Unit intervals used to adjust exclusive bounds (`>` / `<`).
/// Example: `> 40ch` → `min-width: 40.1ch` if `'ch': 0.1`.
/// @type Map
$ic-unit-intervals: (
  "px": 1,
  "em": 0.01,
  "rem": 0.1, // common when :root font-size is 62.5%
  "ch": 0.1,  // good for typographic widths
  "":  0
) !default;

/// Wrap output with a @supports guard for container queries.
/// If true, emits `@supports (container-type: inline-size|size) { ... }`.
/// @type Bool
$ic-guard-supports: true !default;

// -----------------------------------------------------------------------------
// Internal helpers (string/number parsing, expression parsing)
// -----------------------------------------------------------------------------

/// Trim leading/trailing spaces from a string.
/// @access private
/// @param {String} $value
/// @return {String}

@function ic-str-trim($value) {
  @if (string.slice($value, 1, 1) == " ") {
    @return ic-str-trim(string.slice($value, 2));
  } @else if (string.slice($value, string.length($value), -1) == " ") {
    @return ic-str-trim(string.slice($value, 1, -2));
  } @else {
    @return $value;
  }
}

/// Cast a string value to a Sass number with unit if present.
/// @access private
/// @param {String|Number} $value
/// @return {Number}

@function ic-to-number($value) {
  @if meta.type-of($value) == "number" {
    @return $value;
  } @else if meta.type-of($value) != "string" {
    @error "Value for `ic-to-number` should be a number or a string.";
  }

  $first: string.slice($value, 1, 1);
  $minus: ($first == "-");
  @if ($first == "+" or $first == "-") {
    $work: string.slice($value, 2);
  } @else {
    $work: $value;
  }

  $result: 0;
  $digits: 0;
  $numbers: ("0":0,"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9);

  @for $i from 1 through string.length($work) {
    $ch: string.slice($work, $i, $i);

    @if not (list.index(map.keys($numbers), $ch) or $ch == ".") {
      @return ic-to-length(if($minus, -$result, $result), string.slice($work, $i));
    }

    @if $ch == "." {
      $digits: 1;
    } @else if $digits == 0 {
      $result: $result * 10 + map.get($numbers, $ch);
    } @else {
      $digits: $digits * 10;
      $result: $result + math.div(map.get($numbers, $ch), $digits);
    }
  }

  @return if($minus, -$result, $result);
}

/// Attach a CSS unit to a unitless number parsed from a string.
/// @access private
/// @param {Number} $value
/// @param {String} $unit
/// @return {Number}

@function ic-to-length($value, $unit) {
  $units: (
    "px": 1px, "cm": 1cm, "mm": 1mm, "%": 1%, "ch": 1ch, "pc": 1pc,
    "in": 1in, "em": 1em, "rem": 1rem, "pt": 1pt, "ex": 1ex,
    "vw": 1vw, "vh": 1vh, "vmin": 1vmin, "vmax": 1vmax
  );

  @if not list.index(map.keys($units), $unit) {
    @error "Invalid unit `#{$unit}`.";
  }

  @return $value * map.get($units, $unit);
}

/// Slice a Sass list between indexes (inclusive).
/// @access private
/// @param {List} $list
/// @param {Number} $start [1]
/// @param {Number} $end [length($list)]
/// @return {List}

@function ic-slice($list, $start: 1, $end: list.length($list)) {
  @if list.length($list) < 1 or $start > $end {
    @return ();
  }
  $out: ();
  @for $i from $start through $end {
    $out: list.append($out, list.nth($list, $i), comma);
  }
  @return $out;
}

/// Return the comparison operator found in a condition string.
/// Supports: >=, >, <=, <, ≥, ≤
/// @access private
/// @param {String} $expr
/// @return {String}

@function ic-get-operator($expr) {
  @each $op in (">=" , ">" , "<=" , "<" , "≥" , "≤") {
    @if string.index($expr, $op) {
      @return $op;
    }
  }
  @error "No operator found in `#{$expr}`.";
}

/// Determine the dimension keyword (width, height, inline-size, block-size).
/// Defaults to width if omitted.
/// @access private
/// @param {String} $expr
/// @param {String} $operator
/// @return {String}

@function ic-get-dimension($expr, $operator) {
  $op-index: string.index($expr, $operator);
  $raw: ic-str-trim(string.slice($expr, 0, $op-index - 1));
  @if string.length($raw) > 0 {
    @return $raw;
  }
  @return "width";
}

/// Map a comparison operator to min/max prefix.
/// @access private
/// @param {String} $operator
/// @return {String} "min" or "max"
@function ic-get-prefix($operator) {
  @return if(list.index(("<","<=","≤"), $operator), "max", "min");
}

/// Compute the numeric value from the right-hand side of an expression.
/// Applies the unit-interval tweak for exclusive bounds.
/// @access private
/// @param {String} $expr
/// @param {String} $operator
/// @return {Number}

@function ic-get-value($expr, $operator) {
  $op-index: string.index($expr, $operator);
  $raw: ic-str-trim(string.slice($expr, $op-index + string.length($operator)));
  $value: null;

  // Named breakpoint?
  @if map.has-key($ic-breakpoints, $raw) {
    $value: map.get($ic-breakpoints, $raw);
  } @else {
    $value: ic-to-number($raw);
  }

  $unit: math.unit($value);
  $interval: map.get($ic-unit-intervals, $unit);

  @if $interval == null {
    @error "Unknown unit `#{$unit}` in `#{$expr}`.";
  }

  @if ($operator == ">") {
    $value: $value + $interval;
  } @else if ($operator == "<") {
    $value: $value - $interval;
  }

  @return $value;
}

/// Parse a single condition into a valid container query clause (without parentheses).
/// Examples:
/// - ">=md"           → "min-width: 768px"
/// - "<=lg"           → "max-width: 1024px"
/// - "height >= 40ch" → "min-height: 40ch"
/// - "block-size < 60ch" → "max-block-size: 60ch"
/// @access private
/// @param {String} $expr
/// @return {String}

@function ic-parse-expression($expr) {
  // Shorthand dimension keywords supported: width (default), height, inline-size, block-size
  @if map.has-key($ic-breakpoints, $expr) {
    // If someone passes a bare key, treat as min-width
    @return "min-width: #{map.get($ic-breakpoints, $expr)}";
  }

  // Static aliases? (not used by default, kept for symmetry)
  // None by default.

  $operator: ic-get-operator($expr);
  $dimension: ic-get-dimension($expr, $operator); // width|height|inline-size|block-size (or custom)
  $prefix: ic-get-prefix($operator);              // min|max
  $value: ic-get-value($expr, $operator);         // Number

  @return "#{$prefix}-#{$dimension}: #{$value}";
}

// -----------------------------------------------------------------------------
// Context mixin (tweakpoints)
// -----------------------------------------------------------------------------

/// Temporarily extend the breakpoints map within the block scope.
/// @param {Map} $tweakpoints [()] e.g. ('tall': 70ch)
/// @example scss
///   @include container-context(('tall': 70ch)) {
///     @include container('height >= tall') { ... }
///   }
@mixin container-context($tweakpoints: ()) {
  $saved: $ic-breakpoints;
  $ic-breakpoints: map.merge($ic-breakpoints, $tweakpoints) !global;
  @content;
  $ic-breakpoints: $saved !global;
}

// -----------------------------------------------------------------------------
// Main API
// -----------------------------------------------------------------------------

/// Generate container queries from shorthand conditions.
/// Multiple conditions are combined with logical AND by nesting @container rules.
/// Optionally guard with @supports (container-type: inline-size|size).
///
/// @param {ArgList} $conditions  One or more strings like '>=md', '<lg', 'height >= 40ch'
/// @param {String|null} $name    Optional container-name to target
/// @param {String|null} $type    'inline-size' (default) or 'size' for the @supports guard
/// @param {Bool|null} $supports  Override wrapper; defaults to `$ic-guard-supports`
///
/// @example scss - Basic
///   @include container('>=md') { ... }
///
/// @example scss - Named container
///   @include container('>=lg', $name: 'layout') { ... }
///
/// @example scss - Height condition
///   @include container('height >= 50ch') { ... }
///
/// @example scss - Combined
///   @include container('>=sm', '<=lg') { ... }
@mixin container($conditions..., $name: null, $type: null, $supports: null) {
  $supports: if($supports == null, $ic-guard-supports, $supports);
  $type: if($type == null, inline-size, $type);

  // No conditions -> nothing to emit
  @if list.length($conditions) == 0 {
    @content;
  }

  // Parse first condition to a clause WITHOUT parentheses
  $first: list.nth($conditions, 1);
  $clause: ic-parse-expression($first);

  // Optional name prefix (e.g., "layout ")
  $prefix: if($name != null and $name != "", $name + " ", "");

  // Build the @container rule body with required parentheses
  @if $supports {
    @supports (container-type: #{$type}) {
      @container #{$prefix}(#{$clause}) {
        $rest: ic-slice($conditions, 2);
        @if list.length($rest) > 0 {
          // Prevent nested @supports; pass supports=false for subsequent conditions
          @include container($rest..., $name: $name, $type: $type, $supports: false) {
            @content;
          }
        } @else {
          @content;
        }
      }
    }
  } @else {
    @container #{$prefix}(#{$clause}) {
      $rest: ic-slice($conditions, 2);
      @if list.length($rest) > 0 {
        @include container($rest..., $name: $name, $type: $type, $supports: false) {
          @content;
        }
      } @else {
        @content;
      }
    }
  }
}

/// Backwards-compatible alias in case a project already uses a `container` mixin name.
/// @example scss
///   @include include-container('>sm') { ... }
@mixin include-container($conditions..., $name: null, $type: null, $supports: null) {
  @include container($conditions..., $name: $name, $type: $type, $supports: $supports) {
    @content;
  }
}